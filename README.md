# Terraform AWS Platform Template

A production-ready Terraform template that bootstraps an AWS S3 remote backend with strong environment separation, guardrails, and a single setup wizard experience.

## Features

- **One-command setup** - Interactive wizard generates all configs and provisions IAM
- **Self-bootstrapping** - Bootstrap state persists to the S3 bucket it creates
- **Terraform-managed permissions** - Execution role permissions defined in code, updated via bootstrap
- **Environment isolation** - Separate AWS accounts/state per environment (dev/stage/prod)
- **Native lockfiles** - Uses Terraform 1.14+ S3 backend with `use_lockfile = true`
- **GitHub Actions CI/CD** - Two simple workflows for bootstrap and live infrastructure
- **Guardrails** - Account/region checks prevent cross-environment mistakes

## Quick Start

```bash
# 1. Clone this template
git clone <this-repo> my-infra
cd my-infra/infra

# 2. Run the setup wizard
./scripts/setup.sh      # Linux/macOS
./scripts/setup.ps1     # Windows PowerShell

# 3. The wizard will:
#    - Prompt for org prefix, region, KMS/logging options
#    - Prompt for dev account (required), stage/prod (optional)
#    - Optionally provision OIDC provider and IAM roles
#    - Generate all configuration files
#    - Output GitHub secrets to configure

# 4. Commit and push
git add -A && git commit -m "Configure Terraform"
git push origin main

# 5. Bootstrap (one-click)
#    Actions → Bootstrap → Run workflow → Select env: dev
#    Creates S3 bucket, KMS key, and execution role policy

# 6. Deploy infrastructure
#    - Open PR → automatic plan
#    - Merge to main → automatic apply (with environment approval)
```

## Repository Structure

```
infra/
├── bootstrap/                    # Backend provisioning
│   ├── main.tf                   # S3 bucket, KMS key
│   ├── execution-policy.tf       # Managed IAM policy for execution role
│   ├── dev.tfvars                # Generated by setup wizard
│   └── dev.backend.hcl           # Generated by setup wizard
├── live/                         # Deployable stacks by environment
│   ├── dev/
│   │   └── storage/
│   │       ├── main.tf
│   │       ├── backend.hcl       # Generated by setup wizard
│   │       └── terraform.tfvars  # Generated by setup wizard
│   ├── stage/
│   └── prod/
├── modules/                      # Reusable modules
└── scripts/
    ├── setup.sh                  # Setup wizard (bash)
    ├── setup.ps1                 # Setup wizard (PowerShell)
    ├── tf                        # CLI wrapper (bash)
    └── tf.ps1                    # CLI wrapper (PowerShell)
```

## Setup Wizard

The setup wizard (`setup.sh` / `setup.ps1`) handles everything:

1. **Configuration prompts**
   - Organization prefix (e.g., `acme`)
   - Primary AWS region
   - KMS encryption (recommended for production)
   - S3 access logging (optional)
   - GitHub org/repo for OIDC
   - Dev AWS account (required)
   - Stage/Prod AWS accounts (optional - press Enter to skip)

2. **IAM provisioning** (optional, requires AWS admin access)
   - Creates GitHub OIDC identity provider
   - Creates `TerraformBootstrapRole` (manages state bucket + execution policy)
   - Creates `TerraformExecutionRole` (deploys infrastructure)

3. **Config file generation**
   - `bootstrap/<env>.tfvars` and `bootstrap/<env>.backend.hcl`
   - `live/<env>/<stack>/backend.hcl` and `terraform.tfvars`

4. **Outputs GitHub secrets** needed for CI/CD

## Bootstrap Process

The bootstrap workflow handles:

1. **State bucket creation** - S3 bucket with versioning, encryption, lockfiles
2. **KMS key** (optional) - For server-side encryption
3. **Execution role policy** - Terraform-managed IAM policy attached to execution role

**First run**: Detects bucket doesn't exist → creates with local state → migrates to S3
**Later runs**: Uses existing S3 backend → applies any changes (including policy updates)

Just run: **Actions → Bootstrap → Run workflow → Select environment**

## Managing Execution Role Permissions

The execution role's permissions are **managed by Terraform** in `bootstrap/execution-policy.tf`.

### Built-in Permissions

S3 permissions are automatically scoped to your `org_prefix`:

```hcl
# In bootstrap/dev.tfvars
enable_s3_permissions = true  # Grants s3:* on ${org_prefix}-* buckets
```

### Adding More Permissions

Edit your environment's tfvars to add EC2, Lambda, DynamoDB, etc:

```hcl
# In bootstrap/dev.tfvars
extra_execution_policy_statements = [
  {
    Sid      = "LambdaManagement"
    Effect   = "Allow"
    Action   = ["lambda:*"]
    Resource = "arn:aws:lambda:*:*:function:myorg-*"
  }
]
```

Then run the **Bootstrap** workflow to apply changes.

## GitHub Actions Workflows

Two simple workflows:

| Workflow | Purpose |
|----------|---------|
| `bootstrap.yml` | One-click backend setup + policy management |
| `terraform.yml` | GitOps pipeline for live infrastructure |

### Live Infrastructure Pipeline

| Trigger | Behavior |
|---------|----------|
| Pull Request | `terraform plan` (review changes) |
| Merge to main | `terraform apply` (with environment approval) |

### Required GitHub Environment Secrets

Configure in each GitHub Environment (dev, stage, prod):

| Secret | Description |
|--------|-------------|
| `AWS_REGION` | Primary AWS region |
| `AWS_BOOTSTRAP_ROLE_ARN` | IAM role for bootstrap operations |
| `AWS_ROLE_ARN` | IAM role for stack operations |

**Tip**: Enable "Required reviewers" on stage/prod environments for apply approval.

## Local Development

Local execution is disabled by default. For break-glass scenarios:

```bash
export ALLOW_LOCAL_TF=1
cd infra
./scripts/tf env=dev stack=storage plan
```

## Adding a New Stack

1. Copy an existing stack:
   ```bash
   cp -r infra/live/dev/storage infra/live/dev/newstack
   ```

2. Update `backend.hcl` with new state key

3. Update `main.tf` for your resources

4. Add to workflow matrix in `.github/workflows/terraform.yml`

## Prerequisites

- Terraform CLI 1.14.x
- AWS CLI (for setup wizard IAM provisioning)
- Git

## Notes

- State bucket naming: `<org>-tfstate-<env>-<account>-<region>[-<suffix>]`
- DynamoDB locking is not used; native lockfiles are enabled
- Bootstrap state lives in the same bucket it creates
- Execution role permissions are version-controlled and updated via bootstrap
